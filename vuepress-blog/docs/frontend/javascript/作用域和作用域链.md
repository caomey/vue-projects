# 作用域和作用域链

## GO：Global Object

全局对象：全局属性和全局方法

this     window，
window	object，
document	object， 
glob 	100， 
a	function

**defined**全局函数定义时，继承GO全局对象的属性和方法，内部函数(下一级作用域函数)定义时，继承父级的GO和AO

##  执行期上下文 AO：Activation Object    

自己执行时的对象属性和方法

this	window,
arguments	[],
a			123,
b			function,


**defined**  函数定义时，继承上一级作用域的AO和GO
**doing**   函数执行时，连接属于自己的AO
**done**   函数执行结束后断开自己的AO，不断开其他子函数得到的自己的AO

```
函数4  AO		栈4
函数3  AO		栈3
函数2  AO		栈2
函数1  AO		栈1
       GO	  栈0
```

a.[[scope]]  函数a的隐藏属性，可以理解成一个链表，一个栈，用来存储执期上下文

上级函数执行时和下级函数定义时的链表内容是一样的，继承的方法属性都一样
程序要读到子函数的前提必须要父函数执行

**作用域链**中外部函数不能访问内部函数变量，内部函数可以访问外部函数的变量

## 作用域

**运行期上下文**：当函数执行时，会创建一个称为**执行期上下文**的内部对象。一个执行期上下文定义了一个函数执行时的环境，函数每次执行时的执行上下文都是独一无二的，所以多次调用一个函数会导致创建多个执行上下文，函数每次执行时，都会把新生成的执行期上下文，填充到作用域链的最顶端。当函数执行完毕，它所产生的执行上下文被销毁。

**查找变量**：从作用域链的顶端依次向下查找。



---

## 作用域

1. 全局作用域,全局作用域中的变量,叫做全局变量

2. 局部作用域,局部作用域中的变量,叫做局部变量

1. 局部作用局可以使用全局作用域的变量(函数内部可以使用函数外部的变量,**变量提升**)

2. 函数外部不能使用函数内部的变量

3. 函数中定义的变量**没有使用var**,相当于在函数外部声明了全局变量,在函数内部进行的赋值

   ```js
   function f1(){
       num = 100
   }
   f1()
   console.log(num) // 100
   ```

   ---
   
   
   
   调用一次函数,产生一个执行期上下文,加上全局执行上下文(window),执行上下文栈个数为 n+1

1. 在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象
2. 在全局执行上下文（window）确定后，将其添加到栈中（压栈）
3. 在函数执行上下文**创建**后，将其添加到栈中（压栈）
4. 在当前函数**执行完**后，将栈顶的对象移除（出栈）
5. 当所有的代码执行完后，栈中只剩下window

```js
var a=10					// 1.进入全局执行上下文
var bar=function(x){
    var b=5
    foo(x+b)				//3. 进入foo执行上下文
}
var foo = function(y){
    var c=5
    console.log(a+c+y)
}
bar(10)						//2. 进入bar函数执行上下文
```





